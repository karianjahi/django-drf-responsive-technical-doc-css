<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Technical Documentation Page</title>
    <link rel="stylesheet" href="styles.css">
</head>

<body>
    <div id="my-flex-container">
        <nav id="navbar">
            <header>
                <h1>DRF Documentation</h1>
                <ul>
                    <li class="list-intro"><a class="nav-link" href="#introduction">Introduction</a></li>
                    <li><a class="nav-link" href="#serializers">Serializers</a></li>
                    <li><a class="nav-link" href="#viewsets_and_routers">ViewSets and Routers</a></li>
                    <li><a class="nav-link" href="#authentication_and_permissions">Authentication and Permissions</a></li>
                    <li><a class="nav-link" href="#testing_your_drf_api">Testing your DRF API</a></li>
                </ul>
            </header>
        </nav>
        <main id="main-doc">
            <section class="main-section" id="introduction">
                <header>
                    <h2>Introduction</h2>
                </header>
                <p>
                    Django REST Framework (DRF) is a powerful and flexible toolkit for building Web APIs in Django. While
                    Django itself is excellent for building full-stack applications with templated views, DRF provides the
                    tools necessary to expose Django models and data through a RESTful API. This enables you to build
                    backend services for mobile apps, single-page applications (SPAs), or other external systems that
                    require programmatic access to your data.
                </p>
    
                <p>
                    One of DRF's greatest strengths lies in its abstraction of common tasks like serialization,
                    authentication, permissions, and routing. With minimal configuration, you can set up a secure and robust
                    API endpoint. DRF is built on top of Django, so it inherits Django’s ORM, middleware, and
                    request-handling capabilities.
                </p>
    
                <p>
                    DRF also supports various authentication schemes out of the box (e.g., token-based, session-based,
                    OAuth) and integrates with Django’s built-in user model and permissions. It encourages a clean
                    separation of concerns via serializers and views, allowing you to maintain readable, testable, and
                    maintainable code.
                </p>
    
                <p>
                    Whether you’re building a microservice, a backend for your React/Vue app, or simply want to make your
                    database externally accessible via HTTP, DRF makes the process smoother, faster, and more secure. If
                    you’re already familiar with Django, learning DRF is a logical and productive next step.
                </p>
            </section>
    
            <section class="main-section" id="serializers">
                <header>
                    <h2>Serializers</h2>
                </header>
                <p>
                    Serializers in Django REST Framework are responsible for converting complex data types, such as Django
                    model instances or querysets, into native Python datatypes that can then be easily rendered into JSON,
                    XML, or other content types. Conversely, serializers also handle deserialization, allowing parsed data
                    to be converted back into complex types after validation.
                </p>
    
                <p>
                    DRF provides two main types of serializers: Serializer and ModelSerializer. The base Serializer class
                    gives you full control over how fields are defined and validated, whereas ModelSerializer automates this
                    process based on the fields of a Django model. This can significantly reduce boilerplate code,
                    especially when dealing with large models or complex nested relationships.
                </p>
    
                <p>
                    For example, using a ModelSerializer, you can define a simple serializer for a Book model like this:
                <pre><code>
                    class BookSerializer(serializers.ModelSerializer):
                        class Meta:
                            model = Book
                            fields = ['id', 'title', 'author', 'published_date']
                   </code></pre>
                </p>
    
                <p>
                    You can also customize serialization logic using methods like to_representation() or by using
                    SerializerMethodField for derived data. Validations can be added at the field level or globally using
                    `validate_<field_name>` and `validate()` methods.
                </p>
    
                <p>
                    Understanding serializers is key to building maintainable APIs. They ensure that your input and output
                    data adhere to expected formats, making your API safer and easier to work with for clients.
                </p>
            </section>
    
            <section class="main-section" id="viewsets_and_routers">
                <header>
                    <h2>ViewSets and Routers</h2>
                </header>
                <p>
                    In Django REST Framework, ViewSets are classes that provide actions such as list, create, retrieve,
                    update, and destroy in a single, reusable interface. Instead of manually writing different views for
                    different HTTP methods, DRF’s ViewSet classes bundle related logic into a unified resource controller.
                </p>
                <p>
                    For instance, using a ModelViewSet (a type of ViewSet that integrates with Django models), you can
                    expose full CRUD operations on a model with just a few lines of code:
                <pre>
                    <code>
                        class BookViewSet(viewsets.ModelViewSet):
                                queryset = Book.objects.all()
                                serializer_class = BookSerializer
                    </code>
                </pre>
                </p>
                <p>
                    DRF also provides Routers to automatically generate URLs for your ViewSets. You simply register a
                    viewset with a router and include the router in your Django URLs configuration:
                <pre><code>
                        router = routers.DefaultRouter()
                        router.register(r'books', BookViewSet)
                    </code></pre>
                </p>
                <p>
                    Now, your API supports <code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>PATCH</code>>, and
                    <code>DELETE</code> on the <code>/books/</code> endpoint and
                    <code>/books/<id>/</code>. This convention-over-configuration approach saves time and ensures consistent
                    routing
                    across your application.
                </p>
                <p>
                    Using viewsets and routers is a recommended practice in DRF for keeping your API concise and
                    maintainable, especially when the application grows to include many resources.
                </p>
            </section>
            <section class="main-section" id="authentication_and_permissions">
                <header>
                    <h2>Authentication and Permissions</h2>
                </header>
                <p>
                    Authentication and permissions are essential components of any production-ready API. DRF provides robust
                    support for managing access control through a layered approach.
                </p>
                <p>
                    <strong>Authentication</strong> is the process of verifying the identity of a user or client accessing
                    the API. DRF supports several authentication schemes, including:
                <ul>
                    <li>SessionAuthentication (default in Django admin),</li>
                    <li>BasicAuthentication (username and password),</li>
                    <li>TokenAuthentication (using tokens issued per user),</li>
                    <li>JWT Authentication (via third-party packages like djangorestframework-simplejwt).</li>
                </ul>
                </p>
                <p>
                    You can configure authentication globally in your <code>settings.py</code> file:
                <pre><code>
                        REST_FRAMEWORK = {
                            'DEFAULT_AUTHENTICATION_CLASSES': [
                                 'rest_framework.authentication.TokenAuthentication',
                            ]
                        }
                    </code></pre>
                </p>
                <p>
                    <strong>Permissions</strong> determine what an authenticated (or unauthenticated) user is allowed to do.
                    DRF includes common permission classes such as:
                <ul>
                    <li><code>AllowAny</code> (open to all),</li>
                    <li><code>IsAuthenticated</code> (logged-in users only),</li>
                    <li><code>IsAdminUser</code>(superusers only),</li>
                    <li><code>IsAuthenticatedOrReadOnly</code>(read for all, write for authenticated users).</li>
                </ul>
                </p>
                <p>
                    Custom permissions can also be created by subclassing <code>BasePermission</code>. This allows
                    fine-grained access control based on user roles, object ownership, or other business logic.
                </p>
                <p>
                    Combining authentication and permissions effectively ensures that your API is secure and behaves
                    according to the defined access policies. These are critical for protecting sensitive data and enforcing
                    rules in multi-user applications.
                </p>
            </section>
    
            <section class="main-section" id="testing_your_drf_api">
                <header>
                    <h2>Testing Your DRF API</h2>
                </header>
                <p>
                    Testing is crucial to ensure that your API behaves as expected and that future changes do not introduce
                    regressions. DRF integrates seamlessly with Django’s testing framework, which is based on Python’s
                    built-in <code>unittest</code>.
                </p>
                <p>
                    You can write tests using Django’s <code>TestCase</code> class and DRF’s <code>APIClient</code> or
                    <code>APIRequestFactory</code>. <code>APIClient</code> is especially useful for simulating real HTTP
                    requests in a more user-facing context, while <code>APIRequestFactory</code> is used to test individual
                    views or viewsets more directly.
                </p>
                <p>
                    Here's an example of a simple test using <code>APIClient</code>:
                <pre><code>
                        from rest_framework.test import APIClient
                        from django.test import TestCase
                        from .models import Book
    
                        class BookAPITestCase(TestCase):
                            def setUp(self):
                                self.client = APIClient()
                                self.book = Book.objects.create(title="Sample Book", author="Jane Doe")
    
                            def test_get_books(self):
                                response = self.client.get('/api/books/')
                                self.assertEqual(response.status_code, 200)
                                self.assertIn('Sample Book', response.content.decode())
                    </code></pre>
                </p>
                <p>
                    It is good practice to test for different HTTP methods (<code>GET</code>, <code>POST</code>,
                    <code>PUT</code>, <code>PATCH</code>>, and
                    <code>DELETE</code>), check response codes,
                    and verify permission enforcement. You should also write tests for edge cases, like invalid input data
                    or unauthorized access attempts.
                </p>
                <p>
                    Automated testing increases confidence in your codebase and allows for faster, safer deployments. It’s
                    an indispensable part of the development process, especially for APIs that serve as critical backends
                    for mobile or web applications.
                </p>
            </section>
    
        </main>
    </div>
</body>

</html>